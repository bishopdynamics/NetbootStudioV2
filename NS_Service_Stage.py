#!/usr/bin/env python3
"""
Netboot Studio Service: Stage Server (provides files to clients, based on config)
"""

#    This file is part of Netboot Studio, a system for managing netboot clients
#    Copyright (C) 2020-2021 James Bishop (james@bishopdynamics.com)


import sys
import json
import yaml
import logging
import argparse
import pathlib
import socket
import ssl
import scapy.all

from aiohttp import web

from NSClientManager import NSClientManager
from NSLogger import get_logger
from NSService import NSService
from NSCommon import validate_boot_image_metadata


class NSStageService(NSService):
    """
    Netboot Studio Stage Service. Serves the "stage" files: stage2.ipxe, unattended.cfg, stage4.sh, packages/, boot_images/, and iso/, based on client config
    """

    def __init__(self, args):
        """
        Stage Service
        :param args: command-line arguments
        :type args: Namespace
        """
        super().__init__(args)
        logging.info('Netboot Studio Stage Server v%s', self.version)
        self.client_manager = NSClientManager(self.config, self.paths, 'NSStageService', self.loop)
        self.stageserver = NSStageServer(self.config, self.paths, self.client_manager, self.loop)
        self.stopabbles['client_manager'] = self.client_manager
        logging.info('Stage Server is ready')
        self.start()


class NSStageServer:
    """
    Stage Server provides files: stage2.ipxe, unattended.cfg, stage4.sh, mount.cmd, packages/, boot_images/, and iso/, based on client config
    """
    app = None
    http_thread = None
    site = None
    # TODO this is where all these things are hardcoded, they could be abstracted to python vars
    # TODO NFS should have authentication, this is how that info would get to the client
    # NOTE we set stage-2-url again here, but it is the same as in stage1. This is an opportunity to change stage-2-url after initial fetch
    #   in the future, a request to stage2 that lacks all the expected params could result in returning the standby loop with updated stage-2-url and the second attempt might work better
    stage2_preamble = '''#!ipxe
    ############## this is the preamble generated by Netboot Studio #############
    set netboot-studio-server ${next-server}
    set stage-server http://${netboot-studio-server}:8082
    set boot-images ${stage-server}/boot_images
    set boot-images-nfs-noproto ${netboot-studio-server}:/opt/NetbootStudio/boot_images
    set boot-images-nfs nfs://${boot-images-nfs-noproto}
    set stage-2-url ${stage-server}/stage2.ipxe?mac=${mac}&buildarch=${buildarch}&platform=${platform}&manufacturer=${manufacturer}&chip=${chip}&ip=${ip}&uuid=${uuid}&serial=${serial}&product=${product}&version=${version}&unixtime=${unixtime}&asset=${asset}
    set unattended-url-linux ${stage-server}/unattended.cfg
    set unattended-url-windows ${stage-server}/unattend.xml
    set wimboot-path ${boot-images}/wimboot
    set windows-mount-cmd-url ${stage-server}/mount.cmd
    set arch ${buildarch}
    iseq ${arch} x86_64 && set arch amd64 ||
    iseq ${arch} arm64 && set arch arm64 ||
    :chain-next-stage
    ############## end preamble #############
    
    '''
    stage2_epilogue = '''
    
    ############## this is the epilogue generated by Netboot Studio #############
    
    :fallback-menu
    console
    isset ${menu-timeout} || set menu-timeout 0
    set submenu-timeout ${menu-timeout}
    isset ${menu-default} || set menu-default chain-next-stage
    menu Stage 2 Troubleshooting Menu
    isset ${ip} && item --gap -- ------ ip: ${ip} MAC: ${mac} ------- || item --gap -- ------ NO NETWORK!!! -------
    item --gap --
    ## list items here ##
    item chain-next-stage Try Same Stage 2 Again
    item re-fetch-stage2 Fetch Stage 2 Again
    item setup-network Re-Attempt Network Auto-Configure
    item interactive-shell  iPXE Shell
    item interactive-config iPXE Config
    item reboot Reboot
    item exit Exit
    ## end of items list ##
    choose --default ${menu-default} --timeout ${menu-timeout} target && goto ${target}
    
    :re-fetch-stage2
    imgexec ${stage-2-url} || goto failed
    goto fallback-menu
    
    :setup-network
    echo
    echo Configuring Network...
    # https://ipxe.org/cfg/user-class
    # Length 4, value 'i' (0x69), 'P' (0x50), 'X' (0x48), 'E' (0x45)
    set user-class:hex 04:69:50:48:45
    dhcp || goto network-failed
    echo
    goto fallback-menu
    
    :interactive-shell
    echo dropping to iPXE Shell
    shell || goto failed
    goto fallback-menu
    
    :interactive-config
    echo dropping to interactive config
    config || goto failed
    goto fallback-menu
    
    :failed
    echo Something failed, hopefully errors are printed above this
    prompt Press any key to show troubleshooting menu ||
    goto fallback-menu
    
    :network-failed
    echo Failed to auto-configure networking
    echo Second stage will not work!
    prompt Press any key to show troubleshooting menu ||
    goto fallback-menu
    
    :reboot
    echo rebooting
    reboot
    
    :exit
    exit 0
    ############# end of epilogue #############
    
    '''
    stage2_standby_loop = '''
    # this is the standby loop generated by Netboot Studio
    :stage2-content
    # milliseconds, time to wait to check for new instructions
    set delay-time 10000
    console
    echo Netboot Studio
    echo This client is in standby loop, goto https://${netboot-studio-server}:8080/ to configure
    echo If booted from removable media, it can be removed now
    echo
    echo mac: ${mac}, ip: ${ip}, platform: ${platform}
    echo arch: ${buildarch}, manufacturer: ${manufacturer}
    echo
    echo will check for new instructions in ${delay-time} milliseconds
    prompt --key 0x02 --timeout ${delay-time} Press Ctrl-B for the troubleshooting menu... && goto fallback-menu ||
    echo
    echo
    sleep 1
    imgexec ${stage-2-url} || goto failed
    '''
    # TODO dynamically generate menu from available boot_images
    stage2_menu = '''
    # this is the menu generated by Netboot Studio
    :stage2-content
    echo menu doesnt exist yet
    goto failed
    '''

    def __init__(self, config, paths, client_mgr, loop):
        """
        Stage Server
        :param config: config object
        :type config: RawConfigParser
        :param paths: paths object
        :type paths: dict
        :param client_mgr: client manager
        :type client_mgr: NSClientManager
        :param loop: asyncio loop
        :type loop: AbstractEventLoop
        """
        self.config = config
        self.paths = paths
        self.client_manager = client_mgr
        self.loop = loop
        self.host = '0.0.0.0'
        self.port = int(config.get('stageserver', 'port'))
        # TODO remember this is http right now
        self.stage_server_url = 'http://%s:%s' % (self.config.get('main', 'netboot_server_hostname'), self.config.get('stageserver', 'port'))
        try:
            logging.info('Starting HTTP Stage Server on port %s' % self.port)
            self.app = web.Application()
            self.setup_routes()
            self.ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_context.load_cert_chain(self.paths['ssl_cert'], self.paths['ssl_key'])
            self.runner = web.AppRunner(self.app, access_log=None)  # access_log can be set to logging.Logger instance, or None to mute logging
            self._prepare_async_tasks()
        except Exception as ex:
            logging.error('Unexpected Exception while setting up Stage Server: %s', ex)

    @staticmethod
    def format_log_message(client_data, message):
        """
        Format log messages with info about client
        :param client_data: client data
        :type client_data: dict
        :param message: message
        :type message: str
        :return: formatted message
        :rtype: str
        """
        return 'Client: %s (ip: %s, arch: %s) -> %s' % (client_data['mac'], client_data['ip'], client_data['info']['dhcp']['arch'], message)

    def log_info(self, client_data, message):
        """
        Format info-level messages
        :param client_data: client data
        :type client_data: dict
        :param message: message
        :type message: str
        """
        logging.info(self.format_log_message(client_data, message))

    def log_warn(self, client_data, message):
        """
        Format warning-level messages
        :param client_data: client data
        :type client_data: dict
        :param message: message
        :type message: str
        """
        logging.warning(self.format_log_message(client_data, message))

    def log_error(self, client_data, message):
        """
        Format error-level messages
        :param client_data: client data
        :type client_data: dict
        :param message: message
        :type message: str
        """
        logging.error(self.format_log_message(client_data, message))

    def get_client(self, client_ip):
        """
        Get client data by mac address, and update ip address and hostname
        :param client_ip: client ip address
        :type client_ip: str
        :return: client data
        :rtype: dict
        """
        client_mac = scapy.all.getmacbyip(client_ip)
        client_hostname = self.get_hostname(client_ip)
        client_data = self.client_manager.get_client(client_mac)
        if client_data:
            if client_data['ip'] != client_ip:
                logging.warning('Client with mac: %s, arch: %s,  changed ip ( %s -> %s )' % (client_mac, client_data['info']['dhcp']['arch'], client_data['ip'], client_ip))
                client_data['ip'] = client_ip
                self.client_manager.set_client_ip(client_mac, client_ip)
            if client_data['hostname'] != client_hostname:
                logging.warning('Client with mac: %s, arch: %s,  changed hostname ( %s -> %s )' % (client_mac, client_data['info']['dhcp']['arch'], client_data['hostname'], client_hostname))
                client_data['hostname'] = client_hostname
                self.client_manager.set_client_hostname(client_mac, client_hostname)
        return client_data

    def wrap_stage2_error(self, error):
        content = '''
        echo An error occured: %s
        goto failed
        ''' % error
        final_content = self.stage2_preamble + content + self.stage2_epilogue
        return final_content

    def wrap_stage2_content(self, image_name, client_data, content):
        settings = self.client_manager.get_settings()
        variables = '''
        #### variables added by Netboot Studio
        # boot-image-name will always be set to match the name of the boot image
        set boot-image-name %s
        set boot-image-path ${boot-images}/${boot-image-name}
        set boot-image-path-nfs ${boot-images-nfs}/${boot-image-name}
        set client-ip %s
        set client-mac %s
        set client-hostname %s
        set client-arch %s
        set debian-mirror %s
        set ubuntu-mirror %s
        #### end variables
        echo Booting ${boot-image-name}...
        
        ''' % (image_name, client_data['ip'], client_data['mac'], client_data['hostname'], client_data['arch'], settings['debian_mirror'], settings['ubuntu_mirror'])
        final_content = self.stage2_preamble + variables + content + self.stage2_epilogue
        return final_content

    @staticmethod
    def get_hostname(client_ip):
        """
        Get client hostname from ip address
        :param client_ip: ip address
        :type client_ip: str
        :return: hostname
        :rtype: str
        """
        try:
            hostname = socket.gethostbyaddr(client_ip)[0]
        except Exception:
            hostname = 'unknown'
        return hostname

    def _prepare_async_tasks(self):
        """
        prepare async tasks for webserver
        """
        # this will run in its own thread so it needs its own event loop
        self.loop.run_until_complete(self.runner.setup())
        # TODO setting up a linux kernel with our certificate chain trusted is difficult, so stage2 and later must be http for now
        # self.site = web.TCPSite(self.runner, self.host, self.port, ssl_context=self.ssl_context)
        self.site = web.TCPSite(self.runner, self.host, self.port)
        self.loop.run_until_complete(self.site.start())

    def setup_routes(self):
        """
        Setup routes for webserver endpoints
        """
        # setup all the routes handled by webserver
        self.app.add_routes([web.get('/stage2.ipxe', self.get_stage2)])
        self.app.add_routes([web.get('/unattend.cfg', self.get_unattended)])
        self.app.add_routes([web.get('/unattended.cfg', self.get_unattended)])
        self.app.add_routes([web.get('/unattend.xml', self.get_unattended)])
        self.app.add_routes([web.get('/unattended.xml', self.get_unattended)])
        self.app.add_routes([web.get('/preseed.cfg', self.get_unattended)])
        self.app.add_routes([web.get('/stage4.sh', self.get_stage4_unix)])
        self.app.add_routes([web.get('/stage4.bat', self.get_stage4_windows)])
        self.app.add_routes([web.get('/client_state', self.get_client_state)])
        self.app.add_routes([web.get('/mount.cmd', self.get_windows_mountcmd)])
        self.app.add_routes([web.static('/packages/', self.paths['packages'])])
        self.app.add_routes([web.static('/boot_images/', self.paths['boot_images'])])
        self.app.add_routes([web.static('/iso/', self.paths['iso'])])

    async def get_stage2(self, request):
        """
        Get stage2.ipxe, according to client config
        :param request: web request
        :type request: web.Request
        :return: web response
        :rtype: web.Response
        """
        # handle requests for /stage2.ipxe
        #   this is where client ip is updated again
        # ${mac}&buildarch=${buildarch}&platform=${platform}&manufacturer=${manufacturer}&chip=${chip}
        # &ip=${ip}&uuid=${uuid}&serial=${serial}&product=${product}&version=${version}&unixtime=${unixtime}&asset=${asset}
        try:
            client_data = self.get_client(request.remote)
            if not client_data:
                raise Exception('client was not found')
        except Exception as ex:
            content = self.wrap_stage2_error(ex)
            return web.Response(text=content, status=200, content_type='text/plain')
        try:
            args = request.rel_url.query
            try:
                info_ipxe = {
                    'buildarch': args['buildarch'],
                    'platform': args['platform'],
                    'manufacturer': args['manufacturer'],
                    'chip': args['chip'],
                    'ip': args['ip'],
                    'uuid': args['uuid'],
                    'serial': args['serial'],
                    'product': args['product'],
                    'version': args['version'],
                    'unixtime': args['unixtime'],
                    'asset': args['asset'],
                }
            except KeyError:
                raise Exception('request for stage2.ipxe without the required parameters')
            if str(request.remote) != args['ip']:
                self.log_warn(client_data, 'ip addresses dont match! request: [%s], arg: [%s]' % (str(request.remote), args['ip']))
                self.log_warn(client_data, 'taking the args version')
            client_data['info']['ipxe'] = info_ipxe
            result = self.client_manager.set_client_info(args['mac'], client_data['info'])
            if not result:
                raise Exception('failed to update client info in database')
            boot_image_name = client_data['config']['boot_image']
            do_unattended = client_data['config']['do_unattended']
            if boot_image_name:
                if boot_image_name == 'standby_loop':
                    # special option standby_loop is not a real boot_image, but an internally rendered string
                    self.log_info(client_data, 'Serving virtual boot_image: standby_loop')
                    content = self.wrap_stage2_content(boot_image_name, client_data, self.stage2_standby_loop)
                elif boot_image_name == 'menu':
                    # special option menu is not a real boot_image, but an internally rendered string
                    self.log_info(client_data, 'Serving virtual boot_image: menu')
                    content = self.wrap_stage2_content(boot_image_name, client_data, self.stage2_menu)
                else:
                    b_path = self.paths['boot_images'].joinpath(boot_image_name)
                    if pathlib.Path(b_path).is_file():
                        # this is a file boot image, aka a-la-carte
                        with open(b_path, 'r') as bpf:
                            file_content = bpf.read()
                        content = self.wrap_stage2_content(boot_image_name, client_data, file_content)
                        self.log_info(client_data, 'Serving a-la-carte boot_image file: %s' % b_path)
                    elif pathlib.Path(b_path).is_dir():
                        # this is a folder boot image
                        metafile = pathlib.Path(b_path).joinpath('metadata.yaml')
                        with open(metafile, 'r') as mf:
                            metadata = yaml.full_load(mf)
                        metadata['boot_image_name'] = boot_image_name
                        if not validate_boot_image_metadata(metadata):
                            raise Exception('metadata validation failed for boot image: %s' % boot_image_name)
                        if do_unattended:
                            if metadata['supports_unattended']:
                                b_file = b_path.joinpath(metadata['stage2_unattended_filename'])
                            else:
                                raise Exception('tried to do unattended for a boot image that does not support unattended')
                        else:
                            b_file = b_path.joinpath(metadata['stage2_filename'])
                        if metadata['arch'] != 'none':
                            if client_data['arch'] != metadata['arch']:
                                raise Exception('client arch: %s does not match boot image arch: %s' % (client_data['arch'], metadata['arch']))
                        if pathlib.Path(b_file).is_file():
                            with open(b_file, 'r') as bpf:
                                file_content = bpf.read()
                            content = self.wrap_stage2_content(boot_image_name, client_data, file_content)
                            self.log_info(client_data, 'Serving folder boot_image file: %s' % b_file)
                        else:
                            raise Exception('failed to find stage2 file at: %s' % b_file)
                    else:
                        raise Exception('failed to find boot_image named: %s, at path: %s' % (boot_image_name, b_path))
                if not do_unattended:
                    self.client_manager.set_client_state(client_data['mac'], 'stage2', state_text='Stage2: %s' % boot_image_name, description='Client fetched a boot image: %s, and will not be performing an unattended installation' % boot_image_name)
                else:
                    # TODO expiration for do_unattended situation is hardcoded here to 4hrs
                    self.client_manager.set_client_state(client_data['mac'], 'stage2', state_text='Stage2: %s' % boot_image_name, state_expiration_seconds=14400, state_expiration_action='error', description='Client fetched a boot image: %s, and is performing unattended installation' % boot_image_name)
            else:
                raise Exception('failed to get boot_image for client with ip: %s, mac: %s' % (request.remote, args['mac']))
        except Exception as ex:
            # logging.exception('Unexpected exeception while getting stage2 for a client: %s' % ex)
            content = self.wrap_stage2_error(ex)
            self.client_manager.set_client_state(client_data['mac'], 'error', error_short='Stage2: Error', description=str(ex))

        return web.Response(text=content, status=200, content_type='text/plain')

    async def get_unattended(self, request):
        """
        Get unattended.cfg, unattend.cfg, unattend.xml, unattended.xml, preseed.cfg
        :param request: web request
        :type request: web.Request
        :return: web response
        :rtype: web.Response
        """
        # handle requests for /unattend.xml, /unattended.cfg, /preseed.cfg
        try:
            client_data = self.get_client(request.remote)
        except Exception:
            return web.Response(text='', status=500)
        else:
            if client_data:
                try:
                    unattended_file_name = client_data['config']['unattended_config']
                    if unattended_file_name:
                        if unattended_file_name == 'blank.cfg':
                            # special option blank.cfg is not a real file, just returns empty file
                            self.log_info(client_data, 'Serving virtual unattended_config file: blank.cfg')
                            return web.Response(text='', status=200, content_type='text/plain')
                        b_file = self.paths['unattended_configs'].joinpath(unattended_file_name)
                        if pathlib.Path(b_file).is_file():
                            with open(b_file, 'r') as bpf:
                                content = bpf.read()
                            self.log_info(client_data, 'Serving unattended file: %s' % b_file)
                            self.client_manager.set_client_state(client_data['mac'], 'unattended', state_text='Unattended: %s' % unattended_file_name, description='Client fetched unattended config: %s' % unattended_file_name)
                            return web.Response(text=content, status=200, content_type='text/plain')
                        else:
                            raise Exception('unable to find unattended_config file: %s' % b_file)
                    else:
                        raise Exception('failed to lookup unattended_config for client with ip: %s' % request.remote)
                except Exception as ex:
                    logging.exception('Unexpected exeception while getting unattended config for a client')
                    self.client_manager.set_client_state(client_data['mac'], 'error', error_short='Unattended: Error', description=str(ex))
        return web.Response(text='', status=500)

    async def get_stage4_unix(self, request):
        """
        Get stage4.sh for unix-like systems
        :param request: web request
        :type request: web.Request
        :return: web response
        :rtype: web.Response
        """
        # handle requests for /stage4.sh
        # TODO if file is None then we are getting the entry, but if file is 'none' then we are blankscript. this vocab is not self explanitory enough
        try:
            client_data = self.get_client(request.remote)
        except Exception:
            return web.Response(text='', status=500)
        else:
            if client_data:
                try:
                    args = request.rel_url.query
                    next_script = client_data['config']['stage4']
                    try:
                        filename = args['file']
                    except KeyError:
                        filename = None
                    if filename is None:
                        # special stage4.sh entry for unix style systems
                        with open(self.paths['stage4-entry-unix'], 'r') as entryfile:
                            stage4_entry_content = entryfile.read()
                        stage4_entry_preamble = (
                            '#!/usr/bin/env bash\n'
                            '# this is the preamble to the stage4-entry script for unix-style systems, auto-generated by Netboot Studio\n'
                            'export STAGE_SERVER="%s"\n'
                            'NEXT_SCRIPT="%s"\n'
                            '# end preamble\n'
                         ) % (self.stage_server_url, next_script)
                        stage4_entry = stage4_entry_preamble + stage4_entry_content
                        self.log_info(client_data, 'Serving stage4 entry for unix-style systems')
                        self.client_manager.set_client_state(client_data['mac'], 'stage4', state_text='Stage4 Unix-like entry', description='Fetched Stage4 entry for Unix-like systems')
                        return web.Response(text=stage4_entry, status=200, content_type='text/plain')
                    else:
                        full_file_path = pathlib.Path(self.paths['stage4']).joinpath(filename)
                        if full_file_path.is_file():
                            with open(full_file_path, 'r') as bpf:
                                content = bpf.read()
                            self.log_info(client_data, 'Serving stage4 file: %s' % full_file_path)
                            self.client_manager.set_client_state(client_data['mac'], 'stage4', state_text='Stage4 script: %s' % filename, description='Fetched a Stage4 script: %s' % filename)
                            return web.Response(text=content, status=200, content_type='text/plain')
                        else:
                            self.log_error(client_data, 'failed to get stage4.sh filename: %s' % full_file_path)
                            raise Exception('failed to get stage4.sh filename: %s' % full_file_path)
                except Exception as ex:
                    logging.exception('Unexpected exeception while getting stage4 for a client')
                    self.client_manager.set_client_state(client_data['mac'], 'error', error_short='Stage4: Error', description=str(ex))
        return web.Response(text='', status=500)

    async def get_stage4_windows(self, request):
        """
        Get stage4.bat for windows systems
        :param request: web request
        :type request: web.Request
        :return: web response
        :rtype: web.Response
        """
        # handle requests for stage4.bat
        try:
            client_data = self.get_client(request.remote)
        except Exception:
            return web.Response(text='', status=500)
        else:
            if client_data:
                try:
                    args = request.rel_url.query
                    next_script = client_data['config']['stage4']
                    try:
                        filename = args['file']
                    except KeyError:
                        filename = None
                    if filename is None:
                        # special stage4.bat entry for windows systems
                        with open(self.paths['stage4-entry-windows'], 'r') as entryfile:
                            stage4_entry_content = entryfile.read()
                        stage4_entry_preamble = (
                            '@echo off\n'
                            '@REM this is the preamble to the stage4-entry script for windows systems, auto-generated by Netboot Studio\n'
                            'set STAGE_SERVER="%s"\n'
                            'set NEXT_SCRIPT="%s"\n'
                            '@REM end preamble\n'
                        ) % (self.stage_server_url, next_script)
                        stage4_entry = stage4_entry_preamble + stage4_entry_content
                        self.log_info(client_data, 'Serving stage4 entry for windows systems')
                        self.client_manager.set_client_state(client_data['mac'], 'stage4', state_text='Stage4: Windows entry', description='Fetched Stage4 entry for Windows systems')
                        return web.Response(text=stage4_entry, status=200, content_type='text/plain')
                    else:
                        full_file_path = pathlib.Path(self.paths['stage4']).joinpath(filename)
                        if full_file_path.is_file():
                            with open(full_file_path, 'r') as bpf:
                                content = bpf.read()
                            self.log_info(client_data, 'Serving stage4 file: %s' % full_file_path)
                            self.client_manager.set_client_state(client_data['mac'], 'stage4', state_text='Stage4 script: %s' % filename, description='Fetched a Stage4 script: %s' % filename)
                            return web.Response(text=content, status=200, content_type='text/plain')
                        else:
                            self.log_error(client_data, 'failed to get stage4.bat filename: %s' % full_file_path)
                            raise Exception('failed to get stage4.bat filename: %s' % full_file_path)
                except Exception as ex:
                    self.client_manager.set_client_state(client_data['mac'], 'error', error_short='Stage4: Error', description=str(ex))
                    logging.exception('Unexpected exeception while getting stage4 for a client')
        return web.Response(text='', status=500)

    async def get_client_state(self, request):
        """
        Handle the endpoint for client_state. This is not actually a getter, it just uses the arguments to set the client's state
        :param request: web request
        :type request: web.Request
        :return: web response
        :rtype: web.Response
        """
        # handle requests for /client_state
        try:
            client_data = self.get_client(request.remote)
            if client_data:
                args = request.rel_url.query
                state = args['state']
                logging.debug('client state endpoint: %s -> %s' % (client_data['hostname'], state))
                if state == 'error':
                    error_short = args['error_short']
                    description = args['description']
                    self.client_manager.set_client_state(client_data['mac'], 'error', error_short=error_short, description=description)
                else:
                    self.client_manager.set_client_state(client_data['mac'], 'complete')
            else:
                raise Exception('client was not found')
        except Exception as ex:
            logging.exception('Unexpected exeception while handling client state signal for a client: ', ex)
            return web.Response(text=str(ex), status=500, content_type='text/plain')
        else:
            return web.Response(text='OK', status=200, content_type='text/plain')

    async def get_windows_mountcmd(self, request):
        """
        Get mount.cmd. This can be used by windows boot images in order
        :param request: web request
        :type request: web.Request
        :return: web response
        :rtype: web.Response
        """
        # handle requests for /mount.cmd, for windows boot images
        try:
            client_data = self.get_client(request.remote)
            if client_data:
                # remember you have to escape every \ with another \
                netboot_server_ip = self.config.get('main', 'netboot_server_ip')
                boot_image_name = client_data['config']['boot_image']
                samba_path = '\\\\%s\\boot_images\\%s' % (netboot_server_ip, boot_image_name)
                samba_user = self.config.get('samba', 'user')
                samba_pass = self.config.get('samba', 'password')
                content = '''
                @echo off
                echo Netboot Studio is preparing the installer boot image
                echo .
                ipconfig
                echo .
                echo If any of this fails, you will be dropped to a command prompt
                echo this might take a minute...
                net use s: %s %s /user:%s
                echo checking for x:\\windows\\system32\\unattend.xml
                if exist x:\\windows\\system32\\unattend.xml (
                    echo using x:\\windows\\system32\\unattend.xml
                    echo this might take a minute...
                    @echo on
                    s:\\sources\\setup.exe /unattend:x:\\windows\\system32\\unattend.xml
                ) else (
                    echo unattend.xml does not exist
                    echo this might take a minute...    
                    @echo on
                    s:\\sources\\setup.exe
                )
                ''' % (samba_path, samba_pass, samba_user)
                self.log_info(client_data, 'Serving mount.cmd with samba path: %s' % samba_path)
                return web.Response(text=content, status=200, content_type='text/plain')
            else:
                raise Exception('client was not found')
        except Exception:
            logging.exception('Unexpected exeception while getting stage4 for a client')
        logging.error('something unexceptional went wrong while getting stage4 for client')
        return web.Response(text='', status=500)


if __name__ == "__main__":
    # this is the main entry point
    ARG_PARSER = argparse.ArgumentParser(description='Netboot Studio Stage Server', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    ARG_PARSER.add_argument('-m', dest='mode', action='store',
                            type=str, default='prod', choices=['prod', 'dev'],
                            help='which mode to run in')
    ARG_PARSER.add_argument('-c', dest='configdir', action='store',
                            type=str, default='/opt/NetbootStudio',
                            help='path to config folder')
    ARGS = ARG_PARSER.parse_args()
    if ARGS.mode == 'dev':
        # dev mode has info logging, but with lots of extra internal info at each log
        LOG_LEVEL = logging.DEBUG
    else:
        LOG_LEVEL = logging.INFO
    # courtesy of NSLogger
    logger = get_logger(name=__name__,
                        level=LOG_LEVEL)
    assert sys.version_info >= (3, 8), "Script requires Python 3.8+."
    NS = NSStageService(ARGS)
